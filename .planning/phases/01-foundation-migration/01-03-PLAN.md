---
phase: 01-foundation-migration
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - src/state/showStore.ts
  - src/state/index.ts
  - src/app/ErrorBoundary.tsx
  - src/app/AudienceErrorBoundary.tsx
  - src/app/OperatorErrorBoundary.tsx
  - src/main.tsx
  - src/App.tsx
autonomous: true

must_haves:
  truths:
    - "Zustand store works without Provider wrapper (direct import)"
    - "State persists across browser refresh via localStorage"
    - "Error boundary catches component crash and shows fallback UI"
    - "Auto-retry attempts recovery before showing error to operator"
  artifacts:
    - path: "src/state/showStore.ts"
      provides: "Zustand store with persist middleware"
      contains: "persist"
      exports: ["useShowStore"]
    - path: "src/app/ErrorBoundary.tsx"
      provides: "Base error boundary with retry"
      contains: "ErrorBoundary"
    - path: "src/app/AudienceErrorBoundary.tsx"
      provides: "Audience-specific boundary that freezes on crash"
      contains: "fallbackRender"
  key_links:
    - from: "src/App.tsx"
      to: "src/state/showStore.ts"
      via: "useShowStore hook"
      pattern: "useShowStore"
    - from: "src/main.tsx"
      to: "src/app/ErrorBoundary.tsx"
      via: "wraps App"
      pattern: "ErrorBoundary"
    - from: "src/state/showStore.ts"
      to: "localStorage"
      via: "persist middleware"
      pattern: "createJSONStorage.*localStorage"
---

<objective>
Replace React Context with Zustand stores using persist middleware, and add error boundaries with auto-retry.

Purpose: Fulfill ARCH-08 (Zustand, not Context) and ARCH-05 (error boundaries). Per user decisions: state persists across refresh, audience display freezes on crash, operator gets subtle recovery indicator.
Output: Zustand store with localStorage persistence, error boundaries wrapping major sections.
</objective>

<execution_context>
@/Users/jweaker/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/jweaker/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-foundation-migration/01-CONTEXT.md
@.planning/phases/01-foundation-migration/01-RESEARCH.md
@.planning/phases/01-foundation-migration/01-02-SUMMARY.md

# Current context implementation
@src/contexts/Global.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Zustand store with persist middleware</name>
  <files>
    src/state/showStore.ts
    src/state/index.ts
  </files>
  <action>
1. Install Zustand:
   ```bash
   npm install zustand
   ```

2. Create src/state/ directory structure.

3. Create src/state/showStore.ts with persist middleware:
   ```ts
   import { create } from 'zustand'
   import { persist, createJSONStorage } from 'zustand/middleware'

   interface EpisodeData {
     teams: { right: string; left: string }
     [key: string]: unknown
   }

   interface ShowState {
     // Scores
     rightScore: number
     leftScore: number
     
     // Turn state
     rightsTurn: boolean
     turned: boolean
     
     // Question tracking
     quickQuestion: number
     audienceQuestion: number
     
     // Episode data
     data: EpisodeData | null
     
     // Actions
     setRightScore: (score: number) => void
     setLeftScore: (score: number) => void
     addRightScore: (delta: number) => void
     addLeftScore: (delta: number) => void
     setRightsTurn: (isRight: boolean) => void
     toggleTurn: () => void
     setTurned: (turned: boolean) => void
     setQuickQuestion: (index: number) => void
     setAudienceQuestion: (index: number) => void
     setData: (data: EpisodeData) => void
     reset: () => void
   }

   const initialState = {
     rightScore: 0,
     leftScore: 0,
     rightsTurn: false,
     turned: false,
     quickQuestion: 0,
     audienceQuestion: 0,
     data: null,
   }

   export const useShowStore = create<ShowState>()(
     persist(
       (set) => ({
         ...initialState,
         
         setRightScore: (score) => set({ rightScore: score }),
         setLeftScore: (score) => set({ leftScore: score }),
         addRightScore: (delta) => set((state) => ({ rightScore: state.rightScore + delta })),
         addLeftScore: (delta) => set((state) => ({ leftScore: state.leftScore + delta })),
         setRightsTurn: (isRight) => set({ rightsTurn: isRight }),
         toggleTurn: () => set((state) => ({ rightsTurn: !state.rightsTurn, turned: true })),
         setTurned: (turned) => set({ turned }),
         setQuickQuestion: (index) => set({ quickQuestion: index }),
         setAudienceQuestion: (index) => set({ audienceQuestion: index }),
         setData: (data) => set({ data }),
         reset: () => set(initialState),
       }),
       {
         name: 'show-storage', // localStorage key
         storage: createJSONStorage(() => localStorage),
       }
     )
   )
   ```

4. Create src/state/index.ts to export store:
   ```ts
   export { useShowStore } from './showStore'
   ```

5. Note: Do NOT delete the old Context yet - we'll migrate consumers in the next task.
  </action>
  <verify>
    - src/state/showStore.ts exists with persist middleware
    - `npm run dev` starts without errors
    - Open browser devtools, check localStorage has 'show-storage' key after interacting
  </verify>
  <done>
    - Zustand store created with all state from Context
    - Persist middleware configured with localStorage
    - Store exports typed interface
  </done>
</task>

<task type="auto">
  <name>Task 2: Migrate components from Context to Zustand</name>
  <files>
    src/App.tsx
    src/main.tsx
    src/screens/Home.tsx
    src/screens/Windows.tsx
    src/screens/QuestionPicker.tsx
    src/screens/Question.tsx
    src/screens/Rate.tsx
    src/screens/Set.tsx
    src/components/Score.tsx
    src/contexts/Global.tsx (delete)
    src/contexts/index.ts (delete)
  </files>
  <action>
1. Update each file that uses useGlobalContext to use useShowStore:

   **Pattern for migration:**
   ```ts
   // Before
   import { useGlobalContext } from './contexts/Global'
   const { rightScore, setRightScore, leftScore } = useGlobalContext()
   
   // After
   import { useShowStore } from './state'
   const rightScore = useShowStore((state) => state.rightScore)
   const setRightScore = useShowStore((state) => state.setRightScore)
   const leftScore = useShowStore((state) => state.leftScore)
   
   // Or use selector pattern for better performance:
   const { rightScore, leftScore } = useShowStore((state) => ({
     rightScore: state.rightScore,
     leftScore: state.leftScore,
   }))
   ```

2. Update src/App.tsx:
   - Replace useGlobalContext with useShowStore
   - Update keyboard handlers to use store actions

3. Update src/main.tsx:
   - Remove GlobalContextProvider wrapper (Zustand needs no Provider)
   - Keep BrowserRouter

4. Update all screen files to use useShowStore.

5. Handle DATA/setDATA:
   - The Context had DATA from JSON import
   - Move the initial data loading to the store or App component
   - Load default data in App.tsx useEffect if store.data is null:
     ```ts
     import defaultData from './config/data.json'
     
     useEffect(() => {
       if (useShowStore.getState().data === null) {
         useShowStore.getState().setData(defaultData as EpisodeData)
       }
     }, [])
     ```

6. Delete the old Context files:
   - Delete src/contexts/Global.tsx
   - Delete src/contexts/index.ts
   - Delete src/contexts/ directory if empty
  </action>
  <verify>
    - `find src -name "*Context*" -o -name "contexts"` returns empty
    - `npm run dev` works without Context
    - Refresh browser - state persists (scores, current question, etc.)
    - Open new tab - state is shared via localStorage hydration
  </verify>
  <done>
    - All components migrated to Zustand
    - No Context files remain
    - No Provider wrapper in main.tsx
    - State persists across browser refresh
  </done>
</task>

<task type="auto">
  <name>Task 3: Add error boundaries with auto-retry</name>
  <files>
    src/app/ErrorBoundary.tsx
    src/app/AudienceErrorBoundary.tsx
    src/app/OperatorErrorBoundary.tsx
    src/main.tsx
  </files>
  <action>
1. Install react-error-boundary:
   ```bash
   npm install react-error-boundary
   ```

2. Create src/app/ directory for app-level components.

3. Create src/app/ErrorBoundary.tsx - base error boundary:
   ```tsx
   import { ErrorBoundary as ReactErrorBoundary } from 'react-error-boundary'
   import type { ReactNode } from 'react'

   interface Props {
     children: ReactNode
     fallback?: ReactNode
   }

   function DefaultFallback({ error, resetErrorBoundary }: { 
     error: Error
     resetErrorBoundary: () => void 
   }) {
     return (
       <div role="alert" style={{ padding: '20px', textAlign: 'center' }}>
         <p>Something went wrong</p>
         <button onClick={resetErrorBoundary}>Try again</button>
       </div>
     )
   }

   export function ErrorBoundary({ children, fallback }: Props) {
     return (
       <ReactErrorBoundary
         fallbackRender={fallback ? () => fallback : DefaultFallback}
         onReset={() => {
           // Reset app state if needed
         }}
       >
         {children}
       </ReactErrorBoundary>
     )
   }
   ```

4. Create src/app/AudienceErrorBoundary.tsx per user decision (freeze on crash):
   ```tsx
   import { Component, type ReactNode } from 'react'

   interface Props {
     children: ReactNode
   }

   interface State {
     hasError: boolean
     lastGoodRender: ReactNode | null
   }

   /**
    * Audience display freezes on last good frame when component crashes.
    * No error UI shown to audience - just frozen content.
    */
   export class AudienceErrorBoundary extends Component<Props, State> {
     private lastGoodSnapshot: ReactNode = null

     constructor(props: Props) {
       super(props)
       this.state = { hasError: false, lastGoodRender: null }
     }

     static getDerivedStateFromError(_error: Error): Partial<State> {
       return { hasError: true }
     }

     componentDidCatch(error: Error, info: React.ErrorInfo) {
       // Log error for debugging but don't show to audience
       console.error('Audience component crashed:', error, info)
     }

     componentDidUpdate(prevProps: Props) {
       // Snapshot successful renders
       if (!this.state.hasError) {
         this.lastGoodSnapshot = prevProps.children
       }
     }

     render() {
       if (this.state.hasError) {
         // Show last good render (frozen frame) or empty
         return this.lastGoodSnapshot ?? <div />
       }
       return this.props.children
     }
   }
   ```

5. Create src/app/OperatorErrorBoundary.tsx per user decision (subtle indicator + recovery):
   ```tsx
   import { ErrorBoundary } from 'react-error-boundary'
   import { useState, useEffect, type ReactNode } from 'react'

   interface Props {
     children: ReactNode
     onSkipSection?: () => void
   }

   function OperatorFallback({ 
     error, 
     resetErrorBoundary,
     onSkipSection
   }: { 
     error: Error
     resetErrorBoundary: () => void
     onSkipSection?: () => void
   }) {
     const [retryCount, setRetryCount] = useState(0)
     const [autoRetrying, setAutoRetrying] = useState(true)

     // Auto-retry once on first error
     useEffect(() => {
       if (autoRetrying && retryCount === 0) {
         const timer = setTimeout(() => {
           setRetryCount(1)
           resetErrorBoundary()
         }, 500)
         return () => clearTimeout(timer)
       }
       setAutoRetrying(false)
     }, [autoRetrying, retryCount, resetErrorBoundary])

     if (autoRetrying) {
       return (
         <div style={{ padding: '10px', display: 'flex', alignItems: 'center', gap: '8px' }}>
           <span style={{ 
             width: '8px', 
             height: '8px', 
             borderRadius: '50%', 
             backgroundColor: 'orange',
             animation: 'pulse 1s infinite'
           }} />
           <span>Recovering...</span>
         </div>
       )
     }

     // Auto-retry failed, show subtle controls
     return (
       <div style={{ 
         padding: '10px', 
         backgroundColor: 'rgba(255,0,0,0.1)', 
         borderRadius: '4px',
         display: 'flex',
         alignItems: 'center',
         gap: '12px'
       }}>
         <span style={{ 
           width: '8px', 
           height: '8px', 
           borderRadius: '50%', 
           backgroundColor: 'red' 
         }} />
         <span style={{ fontSize: '14px' }}>Section error</span>
         <button onClick={resetErrorBoundary} style={{ fontSize: '12px' }}>
           Retry
         </button>
         {onSkipSection && (
           <button onClick={onSkipSection} style={{ fontSize: '12px' }}>
             Skip Section
           </button>
         )}
       </div>
     )
   }

   export function OperatorErrorBoundary({ children, onSkipSection }: Props) {
     return (
       <ErrorBoundary
         fallbackRender={({ error, resetErrorBoundary }) => (
           <OperatorFallback 
             error={error} 
             resetErrorBoundary={resetErrorBoundary}
             onSkipSection={onSkipSection}
           />
         )}
       >
         {children}
       </ErrorBoundary>
     )
   }
   ```

6. Wrap App in error boundary in src/main.tsx:
   ```tsx
   import { ErrorBoundary } from './app/ErrorBoundary'
   
   // In render:
   <ErrorBoundary>
     <BrowserRouter>
       <App />
     </BrowserRouter>
   </ErrorBoundary>
   ```

7. Note: More granular boundaries around sections will be added in Phase 5/6 when we have the operator/audience split.
  </action>
  <verify>
    - src/app/ErrorBoundary.tsx, AudienceErrorBoundary.tsx, OperatorErrorBoundary.tsx exist
    - `npm run dev` starts without errors
    - Manually test error boundary: temporarily add `throw new Error('test')` in a component, verify fallback shows
    - Remove test error, verify app works normally
  </verify>
  <done>
    - Error boundaries created with retry mechanism
    - Audience boundary freezes on last good render
    - Operator boundary shows subtle indicator with auto-retry
    - Skip section escape hatch available
    - App wrapped in root error boundary
  </done>
</task>

</tasks>

<verification>
1. `npm run dev` starts and app renders
2. Interact with app, check localStorage has 'show-storage' key
3. Refresh browser - state persists (scores, etc.)
4. No GlobalContextProvider in source code: `grep -r "GlobalContextProvider" src/` returns empty
5. Temporarily break a component to test error boundary catches crash
6. Run `npm run build` - succeeds
</verification>

<success_criteria>
- Zustand store with persist middleware (localStorage)
- No React Context providers in codebase
- State survives browser refresh
- Error boundaries catch component crashes
- Auto-retry mechanism works before showing error
- Audience-specific boundary freezes on crash (no error shown)
- Operator-specific boundary shows subtle recovery options
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-migration/01-03-SUMMARY.md`
</output>
